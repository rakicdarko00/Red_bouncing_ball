#include "battle_city.h"
#include "map.h"
#include "xparameters.h"
#include "xil_io.h"
#include "xio.h"
#include <math.h>
#include "obstacle_detect.h"

#include <stdbool.h>

//////////////////////////////////////////////////////////////////////////////
// Tweaking paramerters.

#define MAX_JUMP	                    95
#define STEP	                        16


//////////////////////////////////////////////////////////////////////////////

/*
 * GENERATED BY BC_MEM_PACKER
 * DATE: Wed Jul 08 21:00:48 2015
 */

// ***** 16x16 IMAGES *****
#define IMG_16x16_cigle			0x00FF //2 255 Ovo je nas red block

#define IMG_16x16_SpikeUp    	0x013F //5 319
#define IMG_16x16_Black			0x017F //0 383 Pozadina nasa - nebo
#define IMG_16x16_Lifes		    0x01FF //4
#define IMG_16x16_SpikeLeft	    0x023F //3 575
#define IMG_16x16_SpikeDown	    0x153F //6 5439
#define IMG_16x16_SpikeRight	0x1580 //7 5504

#define IMG_16x16_Char_right		0x01FF //1
#define IMG_16x16_Char_move_right  	0x01FF //1
#define IMG_16x16_Char_move_left  	0x01FF //1
#define IMG_16x16_Char_left     	0x01FF //1



// ***** MAP *****

#define MAP_BASE_ADDRESS			639 // MAP_OFFSET in battle_city.vhd
#define MAP_X							0
#define MAP_X2							640
#define MAP_Y							4
#define MAP_W							64
#define MAP_H							56

#define REGS_BASE_ADDRESS               ( MAP_BASE_ADDRESS + MAP_WIDTH * MAP_HEIGHT )
//#define REGS_BASE_ADDRESS               (5439)

#define BTN_DOWN( b )                   ( !( b & 0x01 ) )
#define BTN_UP( b )                     ( !( b & 0x10 ) )
#define BTN_LEFT( b )                   ( !( b & 0x02 ) )
#define BTN_RIGHT( b )                  ( !( b & 0x08 ) )
#define BTN_SHOOT( b )                  ( !( b & 0x04 ) )

#define TANK1_REG_L                     8
#define TANK1_REG_H                     9
#define TANK_AI_REG_L                   4
#define TANK_AI_REG_H                   5
#define TANK_AI_REG_L2                  6
#define TANK_AI_REG_H2                  7
#define TANK_AI_REG_L3                  2
#define TANK_AI_REG_H3                  3
#define TANK_AI_REG_L4                  10
#define TANK_AI_REG_H4                  11
#define TANK_AI_REG_L5                  12
#define TANK_AI_REG_H5                  13
#define TANK_AI_REG_L6                  14
#define TANK_AI_REG_H6                  15
#define TANK_AI_REG_L7                  16
#define TANK_AI_REG_H7                  17
#define BASE_REG_L						0
#define BASE_REG_H	                    1


int lives = 0;
int score = 0;
int mapPart = 1;
int udario_glavom_skok = 0;
int map_move = 0;
int brojac = 0;
int udario_u_blok = 0;
int nivo = 0;
int start_fall = 0;
int jump_cnt = 0;
int flag1 = 1;
int flag2 = 1;
int flag3 = 1;
int lifes = 100;
int won_flag = 0;
int char_move_cnt = 0;

typedef enum {
	b_false, b_true
} bool_t;

typedef enum {
	DIR_STILL, DIR_LEFT, DIR_RIGHT, DIR_UP, DIR_DOWN, DIR_UR, DIR_UL, DIR_DR, DIR_DL
} direction_t;

typedef enum {P_L, P_R, P_U, P_D, P_UR, P_UL, P_DR, P_DL} pos_t;
typedef enum {J_IDLE, J_GOING_UP, J_WAIT_UP_RELESE} jump_fsm_t;

typedef struct {
	unsigned int x;
	unsigned int y;
	direction_t dir;
	unsigned int type;

	bool_t destroyed;

	unsigned int reg_l;
	unsigned int reg_h;
} characters;

characters mario = { 80,	                        // x
		250,		                     // y
		DIR_RIGHT, // dir
		IMG_16x16_Char_right,  			// type

		b_false,                		// destroyed

		TANK1_REG_L,            		// reg_l
		TANK1_REG_H             		// reg_h
		};




static void chhar_spawn(characters * chhar) {
	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + chhar->reg_l ),
			(unsigned int )0x8F000000 | (unsigned int )chhar->type);
	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + chhar->reg_h ),
			(chhar->y << 16) | chhar->x);
}

static void map_update(characters * ch) {
	int x, y, i, j;
	long int addr;

	if (ch->x >= 620 && nivo==0 && flag1==1) {
			nivo=1;
			flag1=0;
				ch->y=369;
				ch->x=60;
				for(i=0;i<=30;i++){
					for(j=0;j<=41;j++){
						if(i==1 && j >15){
							continue;
						}
						map1[i][j]=map2[i][j];
					}
				}
		}

	if (ch->x >= 620 && nivo==1 && flag2==1) {
					nivo=2;
					flag2=0;
						ch->y=9*16;
						ch->x=60;
						for(i=0;i<=30;i++){
							for(j=0;j<=41;j++){
								if(i==1 && j >15){
									continue;
								}
								map1[i][j]=map3[i][j];
							}
						}
				}

	if (ch->x >= 620 && nivo==2 && flag3==1) {
				nivo=3;
				flag3=0;
					ch->y=12*16;
					ch->x=60;
					for(i=0;i<=30;i++){
						for(j=0;j<=41;j++){
							if(i==1 && j >15
									){
								continue;
							}
							map1[i][j]=map4[i][j];
						}
					}
			}

	if (ch->x >= 620 && nivo==3 && lifes>0) {
				ch->y=-1;
				ch->x=-1;
				for(i=0;i<=30;i++){
					for(j=0;j<=41;j++){
						map1[i][j]=map_win[i][j];
					}
				}
				}

	if(lifes==0){
		ch->y=-1;
		ch->x=-1;
		for(i=0;i<=30;i++){
			for(j=0;j<=41;j++){
				map1[i][j]=map_game_over[i][j];
			}
		}

	}

	for (y = 0; y < MAP_HEIGHT; y++) {
		for (x = 0; x < MAP_WIDTH; x++) {
			addr = XPAR_BATTLE_CITY_PERIPH_0_BASEADDR
					+ 4 * (MAP_BASE_ADDRESS + y * MAP_WIDTH + x);
			switch (map1[y][x + map_move]) {
			case 0:
				Xil_Out32(addr, IMG_16x16_Black);
				break;
			case 1:
				Xil_Out32(addr, IMG_16x16_Char_right);
				break;
			case 2:
				Xil_Out32(addr, IMG_16x16_cigle);
				break;
			case 3:
				Xil_Out32(addr, IMG_16x16_SpikeLeft);
				break;
			case 4:
				Xil_Out32(addr, IMG_16x16_Lifes);
				break;
			case 5:
				Xil_Out32(addr, IMG_16x16_SpikeUp);
				break;
			case 6:
				Xil_Out32(addr, IMG_16x16_SpikeDown);
				break;
			case 7:
				Xil_Out32(addr, IMG_16x16_SpikeRight);
				break;
			case 8:
				Xil_Out32(addr, IMG_16x16_Char_move_right);
				break;
			case 9:
							Xil_Out32(addr, IMG_16x16_Char_move_left);
							break;
			case 10:
							Xil_Out32(addr, IMG_16x16_Char_left);
							break;
			default:
				Xil_Out32(addr, IMG_16x16_Black);
				break;
			}
		}
	}
}

static void map_reset(unsigned char * map) {

	unsigned int i;

	for (i = 0; i <= 20; i += 2) {
		Xil_Out32(
				XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + i ),
				(unsigned int )0x0F000000);
	}

}



void obstacle_detection( characters* ch, bool have_obstacle[9], u8 jump_cnt) {
	for(int i=0;i<9;i++){
		have_obstacle[i]=false;
	}


	u8 roundX = (ch->x) >> 4;
	u8 roundY = (ch->y) >> 4;

	if (map1[roundY][roundX] != 0) {/////
		have_obstacle[P_L] = true;
	}
	if (map1[roundY][roundX+1] != 0) {/////
		have_obstacle[P_R] = true;
	}
	if (map1[roundY][roundX] != 0 || map1[roundY][roundX+1] != 0 ) {/////
		have_obstacle[P_U] = true;
	}
	if (map1[roundY+1][roundX] != 0 || map1[roundY+1][roundX+1] != 0) {/////
		have_obstacle[P_D] = true;
	}
	if (map1[roundY][roundX] != 0 || map1[roundY][roundX+1] != 0) {
		have_obstacle[P_UR] = true;
	}
	if (map1[roundY][roundX] != 0 || map1[roundY][roundX-1] != 0) {
		have_obstacle[P_UL] = true;
	}
	if (map1[roundY+1][roundX] != 0 || map1[roundY+1][roundX-1] != 0) {/////
		have_obstacle[P_DR] = true;
	}
	if (map1[roundY+1][roundX] != 0 || map1[roundY+1][roundX+1] != 0) {//////
		have_obstacle[P_DL] = true;
	}

}

bool warning_detect(characters* ch){
	bool ret=false;
	u8 roundX = (ch->x) >> 4;
	u8 roundY = (ch->y) >> 4;

	ret=map1[roundY][roundX] == 3;
	if(ret){
		return true;
	}
	ret=map1[roundY][roundX] == 5;
	if(ret){
			return true;
		}
	ret=map1[roundY][roundX] == 6;
		if(ret){
			return true;
		}
	ret=map1[roundY][roundX] == 7;
		if(ret){
				return true;
		}

	ret=map1[roundY+1][roundX+1] == 3;
	if(ret){
			return true;
		}
	ret=map1[roundY+1][roundX+1] == 5;
	if(ret){
			return true;
		}
	ret=map1[roundY+1][roundX+1] == 6;
		if(ret){
				return true;
			}
	ret=map1[roundY+1][roundX+1] == 7;
	if(ret){
			return true;
		}


	ret=map1[roundY+1][roundX] == 3;
	if(ret){
			return true;
		}
	ret=map1[roundY+1][roundX] == 5;
	if(ret){
			return true;
		}
	ret=map1[roundY+1][roundX] == 6;
	if(ret){
			return true;
		}
	ret=map1[roundY+1][roundX] == 7;
	if(ret){
			return true;
		}


	ret=map1[roundY][roundX+1+1/16] == 3;
	if(ret){
			return true;
		}
	ret=map1[roundY][roundX+1+1/16] == 5;
	if(ret){
			return true;
		}
	ret=map1[roundY][roundX+1+1/16] == 6;
		if(ret){
				return true;
			}
		ret=map1[roundY][roundX+1+1/16] == 7;
		if(ret){
				return true;
			}

	return ret;
}

void blowmind( characters* ch) {
	//u8 roundX = (ch->x) >> 4;
	//u8 roundY = (ch->y) >> 4;
	static int flag_1_spike1=0;
	static int flag_1_spike2=0;
	static int flag_2_switch=0;
	static int i,j;
	static int flag_4_1=0;
	static int flag_4_2=0;
	static int flag_4_3=0;
	static int flag_4_4=0;
	static int flag_4_5=0;
	static int flag_4_6=0;

//LEVEL 0
	if(nivo==0){
		if(ch->x<16){
							for(i=0;i<30;i++){
								map1[i][0]=7;
							}

						}
/*
		if(ch->y==16*16){
			map1[23][4]=2;
			map1[23][5]=2;
			map1[23][6]=2;
			map1[23][7]=5;
			map1[23][8]=5;
			map1[23][9]=5;
		}
		if(ch->y>16*16 && ch->y<400 && ch->x>8*16){
			map1[23][12]=5;
			map1[23][13]=5;
			map1[23][14]=5;
		}

		if(ch->x>25*16){
			map1[19][23]=2;
			map1[19][24]=2;
			map1[19][25]=2;
			map1[19][26]=2;
			map1[19][27]=2;
			map1[19][28]=2;

			map1[19][29]=2;
			map1[19][30]=2;
			map1[19][31]=2;
			map1[19][32]=2;
			map1[19][33]=2;
			map1[19][34]=2;
			map1[19][35]=2;
		}
		if(ch->x>29*16){
			map1[19][31]=0;
			map1[19][32]=0;
			map1[19][33]=0;
			map1[19][34]=0;
			map1[19][35]=0;
		}
*/
		if(lifes>0 && won_flag==0){
						if (warning_detect(ch)) {/////
							map1[1][39-lifes]=2;
							map1[23][4]=0;
							map1[23][5]=0;
							map1[23][6]=0;
							map1[23][7]=0;
							map1[23][8]=0;
							map1[23][9]=0;
							map1[23][12]=0;
							map1[23][13]=0;
							map1[23][14]=0;
							map1[19][23]=0;
							map1[19][24]=0;
							map1[19][25]=0;
							map1[19][26]=0;
							map1[19][27]=0;
							map1[19][28]=0;
							map1[19][29]=0;
							map1[19][30]=0;
							map1[19][31]=0;
							map1[19][32]=0;
							map1[19][33]=0;
							map1[19][34]=0;
							map1[19][35]=0;
							lifes--;
							ch->y=250;
							ch->x=80;
						}
			}


		}


//LEVEL 1
	if(nivo==1){

				if(ch->x<3*16){
					for(i=0;i<30;i++){
						map1[i][1]=7;
					}

				}

				if(ch->x>29*16){
					map1[11][30]=5;
					flag_1_spike1=1;
				}

				if(ch->x<29*16 && flag_1_spike1==1){
					map1[14][26]=5;
					flag_1_spike2=1;
				}

				if(ch->x>36*16){
					map1[12][38]=5;
				}

				if(ch->x>24*16 && ch->y>17*16 && flag_1_spike2==1){
					map1[20][26]=2;
					map1[20][27]=2;
					map1[20][28]=2;
					map1[19][28]=2;
					map1[19][28]=2;
					map1[19][29]=2;
					map1[19][30]=2;
					map1[19][31]=2;
					map1[18][31]=2;
					map1[18][32]=2;
					map1[18][33]=2;
					map1[17][33]=2;
					map1[16][33]=2;
					map1[15][33]=2;
					map1[14][33]=2;
					map1[13][33]=2;
				}

				if(lifes>0 && won_flag==0){
							if (warning_detect(ch)) {/////
								map1[1][39-lifes]=2;
								map1[11][30]=0;
								map1[14][26]=0;
								map1[12][38]=0;
								map1[20][26]=0;
								map1[20][27]=0;
								map1[20][28]=0;
								map1[19][28]=0;
								map1[19][28]=0;
								map1[19][29]=0;
								map1[19][30]=0;
								map1[19][31]=0;
								map1[18][31]=0;
								map1[18][32]=0;
								map1[18][33]=3;
								map1[17][33]=3;
								map1[16][33]=3;
								map1[15][33]=3;
								map1[14][33]=3;
								map1[13][33]=3;
								flag_1_spike1=0;
								flag_1_spike2=0;
								lifes--;
								ch->y=369;
								ch->x=60;
							}
			}


	}

//LEVEL 2

	if(nivo==2){
			if(ch->x>7*16){

				map1[12][5]=7;
				map1[12][6]=0;
				map1[12][7]=0;
				map1[12][8]=0;
	     		map1[12][9]=0;
				map1[12][10]=3;

				map1[13][5]=7;
				map1[13][6]=0;
				map1[13][7]=0;
				map1[13][8]=0;
				map1[13][9]=0;
				map1[13][10]=3;

				map1[14][5]=7;
				map1[14][6]=0;
				map1[14][7]=0;
				map1[14][8]=0;
				map1[14][9]=0;
				map1[14][10]=3;

				map1[15][5]=7;
				map1[15][6]=0;
				map1[15][7]=0;
				map1[15][8]=0;
				map1[15][9]=0;
				map1[15][10]=3;

				map1[16][5]=2;
				map1[16][6]=5;
				map1[16][7]=5;
				map1[16][8]=5;
				map1[16][9]=5;
				map1[16][10]=2;
			}
					if(ch->x>11*16){
					map1[11][13]=5;
					map1[11][14]=5;
					map1[11][15]=5;
					}
					if(ch->x>21*16 && ch->y>12*16){
						map1[17][22]=5;
						map1[17][23]=5;
					}
						if(ch->x>35*16){
							map1[2][39]=2;
							map1[3][39]=2;
							map1[4][39]=2;
							map1[5][39]=2;
							map1[6][39]=2;
							map1[7][39]=2;
							map1[8][39]=2;
							map1[9][39]=2;
							map1[10][39]=2;
							map1[11][39]=2;

							map1[2][38]=3;
							map1[3][38]=3;
							map1[4][38]=3;
							map1[5][38]=3;
							map1[6][38]=3;
							map1[7][38]=3;
							map1[8][38]=3;
							map1[9][38]=3;
							map1[10][38]=3;
							map1[11][38]=3;
						}
						if(ch->x>35*16 && ch->y<6*16){
							flag_2_switch=1;
							map1[5][35]=2;
							map1[29][25]=0;
							map1[29][26]=0;
							map1[29][27]=0;
						}
						if(ch->x>24*16 && ch->x<28*16 && ch->y>28*16 && flag_2_switch==1){

							ch->x = 36*16;
							ch->y = 28*16;

							map1[28][39] = 0;
							map1[28][38] = 0;
							map1[28][37] = 0;
							map1[28][36] = 0;

							map1[27][39] = 0;
							map1[27][38] = 0;
							map1[27][37] = 0;
							map1[27][36] = 0;

							map1[26][39] = 0;
							map1[26][38] = 0;
							map1[26][37] = 0;
							map1[26][36] = 0;

							map1[25][39] = 0;
							map1[25][38] = 0;
							map1[25][37] = 0;
							map1[25][36] = 0;
						}

						if(ch->x>37*16 && ch->y>24*16 && ch->y<29*16){
							map1[28][39] = 5;
						}




			if(lifes>0 && won_flag==0){
				if (warning_detect(ch)) {/////
					map1[1][39-lifes]=2;
					lifes--;
					for(i=0;i<=30;i++){
						for(j=0;j<=41;j++){
							if(i==1 && j >30){
								continue;
							}
							map1[i][j]=map3[i][j];
						}
					}
					ch->y=9*16;
					ch->x=60;
				}
			}
		}

//LEVEL 3

	if(nivo==3){
		if(ch->x>11*16 && ch->x<13*16 && ch->y>16*16){
			map1[17][12]=2;
			flag_4_1=1;
		}

		if(ch->x>15*16 && ch->x<17*16 && ch->y>25*16 && flag_4_1 == 1){
			map1[26][16]=2;
			flag_4_2=1;
		}

		if(flag_4_3 == 1){
			map1[22][23]=2;
			flag_4_4=1;
		}
		if(ch->x>22*16 && ch->x<24*16 && ch->y>25*16 && flag_4_2 == 1){
			map1[26][23]=2;
			flag_4_3=1;
		}

		if(ch->x>26*16 && ch->x<28*16 && ch->y>17*16 && flag_4_4 == 1){
			map1[18][27]=2;
		}

		if(ch->x<35*16 && ch->x>32*16 && ch->y<11*16){
					map1[3][35]=2;
					map1[4][35]=2;
					map1[5][35]=2;
					map1[6][35]=2;
					map1[7][35]=2;
					map1[8][35]=2;
					map1[9][35]=2;
					map1[10][35]=2;
					map1[11][35]=2;
					map1[12][35]=2;
					map1[3][34]=3;
					map1[4][34]=3;
					map1[5][34]=3;
					map1[6][34]=3;
					map1[7][34]=3;
					map1[8][34]=3;
					map1[9][34]=3;
					map1[10][34]=3;
					map1[11][34]=3;

				}

		if(ch->x>36*16)
			map1[14][38]=5;
		if(lifes>0 && won_flag==0){
			if (warning_detect(ch)) {/////
				map1[1][39-lifes]=2;
				lifes--;
				flag_4_1=0;
				flag_4_2=0;
				flag_4_3=0;
				flag_4_4=0;
				map1[17][12]=0;
				map1[26][16]=0;
				map1[22][23]=0;
				map1[26][23]=0;
				map1[18][27]=0;
				map1[3][35]=0;
									map1[4][35]=0;
									map1[5][35]=0;
									map1[6][35]=0;
									map1[7][35]=0;
									map1[8][35]=0;
									map1[9][35]=0;
									map1[10][35]=0;
									map1[11][35]=0;
									map1[12][35]=0;
									map1[3][34]=0;
									map1[4][34]=0;
									map1[5][34]=0;
									map1[6][34]=0;
									map1[7][34]=0;
									map1[8][34]=0;
									map1[9][34]=0;
									map1[10][34]=0;
									map1[11][34]=0;
									map1[12][34]=0;
									map1[14][38]=0;
				ch->y=12*16;
				ch->x=60;
			}
		}
	}

	if(lifes == 0){
		//TODO: call GAME OVER

	}


}

static bool_t character_move(characters* ch, direction_t dir, bool up_pressed) {

	static jump_fsm_t jump_fsm = J_IDLE;
	static u8 jump_cnt;


	static bool have_obstacle[9];


	//direction_t dir_obs=DIR_STILL;
	obstacle_detection(ch, &have_obstacle, jump_cnt);
	blowmind(ch);

	// Jump FSM funkcija prelaza.
	switch (jump_fsm) {
	case J_IDLE:
		if (up_pressed && have_obstacle[P_D]) {
			jump_fsm = J_GOING_UP;
		}
		break;
	case J_GOING_UP:
		if (jump_cnt == MAX_JUMP) {
			jump_fsm = J_WAIT_UP_RELESE;
		}

		switch (dir) {
		case DIR_STILL:
			if(have_obstacle[P_U]){
				jump_fsm = J_WAIT_UP_RELESE;
			}
			break;
		case DIR_LEFT:
			if(have_obstacle[P_UL]){
				jump_fsm = J_WAIT_UP_RELESE;
			}
			break;
		case DIR_RIGHT:
			if(have_obstacle[P_UR]){
				jump_fsm = J_WAIT_UP_RELESE;
			}
			break;
		}

		break;
	case J_WAIT_UP_RELESE:
		if (!up_pressed) {
			jump_fsm = J_IDLE;
		}
		break;
	}

	// Jump FSM funkcija izlaza.
	switch (jump_fsm) {
	case J_IDLE:
		break;
	case J_GOING_UP:
		ch->y--;
		jump_cnt++;
		break;
	case J_WAIT_UP_RELESE:
		jump_cnt = 0;
		break;
	}

	// Falling.

	if(jump_fsm != J_GOING_UP){ // Cannot fall if going up in jumping.

		switch (dir) {
		case DIR_STILL:
			if(!have_obstacle[P_D]){
				ch->y++;
			}
			break;
		case DIR_LEFT:
			if(!have_obstacle[P_DL]){
				ch->y++;
			}
			break;
		case DIR_RIGHT:
			if(!have_obstacle[P_DR]){
				ch->y++;
			}
			break;
		}
	}

	// Moving.

	switch (dir) {
	case DIR_STILL:
		break;
	case DIR_LEFT:
		if(!have_obstacle[P_L]){
			ch->x--;
		}
		break;
	case DIR_RIGHT:
		if(!have_obstacle[P_R]){
			ch->x++;
		}
		break;
	}


	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + ch->reg_h ),
			(ch->y << 16) | ch->x);

	return b_false;
}

void battle_city() {

	unsigned int buttons; /*, tmpBtn = 0, tmpUp = 0;*/
	int i;/*, change = 0, jumpFlag = 0;*/
	/*int block;*/

	map_reset(&map1);
	map_update(&mario);

	//chhar_spawn(&enemie1);
	//chhar_spawn(&enemie2);
	//chhar_spawn(&enemie3);
	//chhar_spawn(&enemie4);
	chhar_spawn(&mario);

	while (1) {
		char_move_cnt++;

		if (char_move_cnt==STEP){
			char_move_cnt=0;
		}

		buttons = XIo_In32( XPAR_IO_PERIPH_BASEADDR );

		direction_t d = DIR_STILL;
		if (BTN_LEFT(buttons)) {
			d = DIR_LEFT;
			if (char_move_cnt==0){
					mario.type=IMG_16x16_Char_left;
					chhar_spawn(&mario);
				}else if (char_move_cnt==(STEP/2)){
					mario.type=IMG_16x16_Char_move_left;
					chhar_spawn(&mario);
				}
		} else if (BTN_RIGHT(buttons)) {
			d = DIR_RIGHT;
			if (char_move_cnt==0){
					mario.type=IMG_16x16_Char_right;
					chhar_spawn(&mario);
				}else if (char_move_cnt==(STEP/2)){
					mario.type=IMG_16x16_Char_move_right;
					chhar_spawn(&mario);
				}
		}

		bool up_pressed = BTN_UP(buttons);

		character_move(&mario, d, up_pressed);

		map_update(&mario);

		for (i = 0; i < 45000; i++) {
		}

	}
}
